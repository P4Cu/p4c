" vim: foldmethod=marker

" netrw is just annoyance - disable it by saying it's already loaded
" let loaded_netrwPlugin = 1

let mapleader = "\<space>"
let g:loaded_python_provider = 0
let g:ale_completion_enabled = 1
" TODO: report a bug that default linters do not merge as specified by doc
let g:ale_linters = {
\ 'python': ['pylsp', 'flake8', 'mypy', 'pylint', 'pyright'],
\ 'rust': ['analyzer'],
\ }
let g:polyglot_disabled = ['markdown'] " due to https://github.com/sheerun/vim-polyglot/issues/478

" PLUGINS #######################################################################################{{{
call plug#begin()
Plug 'lifepillar/vim-gruvbox8'
Plug 'benmills/vimux' " running command in tmux
Plug 'tpope/vim-fugitive' " the ultimate git helper
Plug 'tpope/vim-commentary' " comment/uncomment lines with gcc or gc in visual mode
Plug 'vim-airline/vim-airline' " status line
Plug 'ervandew/supertab' " requires some integration with YCM/UltiSnips
Plug 'rhysd/vim-clang-format', { 'for': ['c', 'cpp'] }
Plug 'tpope/vim-unimpaired'
Plug 'ryanoasis/vim-devicons'
Plug 'vim-scripts/a.vim' " { 'for': ['c', 'cpp'] } TODO: cannot as we're unmapping a few things
Plug 'dyng/ctrlsf.vim'
Plug 'tpope/vim-abolish' " TODO: add it to <leader> so it's easier to find
Plug 'tpope/vim-repeat' " this is required by easyclip  # TODO: do we need it? most probably yes
Plug 'edkolev/tmuxline.vim'
Plug 'christoomey/vim-tmux-navigator'
Plug 'tpope/vim-dispatch'
Plug 'tmux-plugins/vim-tmux-focus-events'
Plug 'vim-scripts/autoswap.vim'
Plug 'airblade/vim-gitgutter'
Plug 'moll/vim-bbye' " :Db
Plug 'kana/vim-textobj-user'
Plug 'kana/vim-textobj-line'
Plug 'michaeljsmith/vim-indent-object'
Plug 'terryma/vim-expand-region'
Plug 'dzeban/vim-log-syntax'
Plug 'embear/vim-foldsearch'
Plug 'dimasg/vim-mark'
Plug 'wsdjeg/vim-fetch' " Open some/file:line:column
Plug 'mhinz/vim-startify'
Plug 'liuchengxu/vim-clap', { 'do': ':Clap install-binary!' }
Plug 'dense-analysis/ale'
Plug 'sheerun/vim-polyglot' " a lot of filetypes
Plug 'plasticboy/vim-markdown'
" Utilitaries {{{
Plug 'vim-scripts/CharTab' " <leader>ct  character tab # TODO: lazy load
Plug 'mechatroner/rainbow_csv' " TODO: lazy load
Plug 'dhruvasagar/vim-table-mode' " TODO: lazy load
Plug 'folke/which-key.nvim' " awesome plugin to show available commands
" }}}
" Experimental {{{
" }}}
" Considered for deletion {{{
Plug 'kana/vim-operator-user' " TODO: most probably not needed
Plug 'mhinz/vim-grepper' " TODO: do I need one if vim-clap can do it?
" Plug 'lyuts/vim-rtags' " TODO: lazyload
" Plug 'valloric/youcompleteme'
" Plug 'davidhalter/jedi-vim', { 'for': 'python' }
" }}}
call plug#end()
" ###############################################################################################}}}


" Generic values ################################################################################{{{
" highlight search
set hlsearch incsearch ignorecase smartcase
set cursorline
" bashlike vim completition + with addition of third tab for list select mode (zsh alike )
set wildmode=longest,list,full
set wildmenu
set mouse=a
set splitright splitbelow
set scrolloff=10 " always show x lines from cursor
set undofile " keep history for each file (allows undo after close) file.un~
set gdefault " rly mate, when i wanted to replace only the first occurence in line?
set lazyredraw
set tabstop=4 shiftwidth=4
set expandtab
set list lcs=trail:·,tab:»· " Whitespace
set numberwidth=5 " Numbering of lines
set norelativenumber number " use <cor> <con> to enable dispalying
set nowrap " use <cow>
set updatetime=1000 timeoutlen=500 ttimeoutlen=0
if has('nvim')
"     set inccommand=nosplit " looks like this is causing a redraw issues
endif
set nowrapscan " do not wrap the search!
if has("patch-8.1.0360")
  set diffopt+=internal,algorithm:patience
endif
set clipboard=unnamedplus
" This will automatically read changed file. It will ask if we have unsaved changes.
set autoread
set sessionoptions=buffers,blank,curdir,folds,help,tabpages,winpos " what to save in sessions - startify
" ###############################################################################################}}}


" THEME #########################################################################################{{{
set termguicolors
colorscheme gruvbox8 " gruvbox8_hard
let airline#extensions#tmuxline#snapshot_file = "~/.tmux/powerline.conf"
" ###############################################################################################}}}


" ##################################################################################################
" to have nice command search
cnoremap <c-p> <up>
cnoremap <c-n> <down>
nnoremap gb :bnext<CR>
nnoremap gB :bprevious<CR>
noremap <C-_> :Commentary<CR>
noremap <F1> :Clap<CR>
" noremap <F1> :YcmCompleter FixIt<CR>
noremap <F3> :Clap buffers<CR>
map <F4> :A<CR>
nmap <F8> :TagbarToggle<CR>
nnoremap <F10> :YcmDiags<CR>
nnoremap <F11> :YcmForceCompileAndDiagnostics<CR>
nnoremap <F12> :YcmToggleLogs<CR>
" youcompleteme mapping
noremap <C-t> :YcmCompleter GoToDeclaration<CR>
noremap <C-g> :YcmCompleter GoTo<CR>

nnoremap [g :echo "use [c"<CR>
nnoremap ]g :echo "use ]c"<CR>
" nnoremap [g :GitGutterPrevHunk<CR>
" nnoremap ]g :GitGutterNextHunk<CR>
nnoremap cog :GitGutterLineHighlightsToggle<CR>

" TODO: would be nice to make a command aout of it and allow anything like HEAD~
" This function toggles diff against HEAD
function! P4C_GitGutterDiffAgainst(revision)
    let g:gitgutter_diff_base = a:revision
    echom 'P4C_GitGutterDiffHeadToggle diff against ' + a:revision
    execute 'silent GitGutter'
endfunction
command -nargs=1 P4CGitGutterAgainst silent call P4C_GitGutterDiffAgainst("<args>")
" ##################################################################################################

" ##################################################################################################
" vim-ariline
set noshowmode
" hi StatusLine 
" Enable the list of buffers
let g:airline#extensions#tabline#enabled = 1
" Show just the filename
let g:airline#extensions#tabline#fnamemod = ':t'
let g:airline#extensions#tabline#buffer_idx_mode = 1
let g:airline#extensions#tabline#show_splits = 0
nmap <leader>1 <Plug>AirlineSelectTab1
nmap <leader>2 <Plug>AirlineSelectTab2
nmap <leader>3 <Plug>AirlineSelectTab3
nmap <leader>4 <Plug>AirlineSelectTab4
nmap <leader>5 <Plug>AirlineSelectTab5
nmap <leader>6 <Plug>AirlineSelectTab6
nmap <leader>7 <Plug>AirlineSelectTab7
nmap <leader>8 <Plug>AirlineSelectTab8
nmap <leader>9 <Plug>AirlineSelectTab9
nmap <leader>[ <Plug>AirlineSelectPrevTab
nmap <leader>] <Plug>AirlineSelectNextTab
" ##################################################################################################

" ##################################################################################################
" MISC
set colorcolumn=101
" ##################################################################################################

" Project specific {{{
" write something like: `autocmd BufRead,BufNewFile /home/p4c/repo/* call P4C_repo()`
" and do customizations in that function
if filereadable(glob("~/.vimrc_custom"))
    source ~/.vimrc_custom
endif
" }}} ##############################################################################################

" Vim session
let g:session_autoload = 'no'
let g:session_autosave = 'yes'
let g:session_command_aliases = 1

" vim-devicons
set guifont=DroidSansMonoForPowerline\ Nerd\ Font\ 11
let g:airline_powerline_fonts=1

" " make YCM compatible with UltiSnips (using supertab)
" let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
" let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
" let g:SuperTabDefaultCompletionType = '<C-n>'

" " better key bindings for UltiSnipsExpandTrigger
" let g:UltiSnipsExpandTrigger = "<tab>"
" let g:UltiSnipsJumpForwardTrigger = "<tab>"
" let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

" " bug with UltiSnips+YCM+SuperTab
" let g:UltiSnipsSnippetDirectories = ['~/.vim/UltiSnips', 'UltiSnips']

" CtrlSF
nmap     <leader>sf <Plug>CtrlSFPrompt
nmap     <leader>ss <Plug>CtrlSFStop
vmap     <leader>sf <Plug>CtrlSFVwordPath
vmap     <leader>sF <Plug>CtrlSFVwordExec
nmap     <leader>sn <Plug>CtrlSFCwordPath
nmap     <leader>sp <Plug>CtrlSFPwordPath
nnoremap <leader>so :CtrlSFOpen<CR>
nnoremap <leader>st :CtrlSFToggle<CR>
" inoremap <leader>st <Esc>:CtrlSFToggle<CR>

" always use buffer delete map
cabbrev bd <c-r>=(getcmdtype()==':' && getcmdpos()==1 ? 'Bd' : 'bd')<CR>

" working with filepaths/numbers
nnoremap cp :let @+ = expand("%:p")<cr><bar>:echo "Copied full file path"<cr>
nnoremap cpl :let @+ = expand("%:p") . ":" . line(".")<cr><bar>:echo "Copied full file path with line number"<cr>

if has('nvim')
    tnoremap <Esc> <C-\><C-n>
    tnoremap <C-h> <C-\><C-n><C-w>h
    tnoremap <C-j> <C-\><C-n><C-w>j
    tnoremap <C-k> <C-\><C-n><C-w>k
    tnoremap <C-l> <C-\><C-n><C-w>l
endif

let g:PyFlakeCheckers = 'pep8'
let g:autoswap_detect_tmux = 1

" Do not jump on pressing star
" noremap <silent> * :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>

vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)

" missing toggle paste
nmap cop :setlocal <C-R>=<SNR>61_toggle("paste")<CR><CR>

" " rtags configuration
" let g:rtagsMinCharsForCommandCompletion=2

" a.vim settings
let g:alternateNoDefaultAlternate = 1

" thats the default
let g:alternateSearchPath = 'sfr:../source,sfr:../src,sfr:../include,sfr:../inc'
let g:alternateSearchPath .= ',sfr:../../include,sfr:../../inc'
let g:alternateSearchPath .= ',sfr:../../source,sfr:../../src'
let g:alternateSearchPath .= ',reg:/include/src/g/'
let g:alternateSearchPath .= ',reg:/src/include/g/'
"            EXAMPLE: 'reg:/inc/src/g/' will replace every instance 
"            of 'inc' with 'src' in the source file path. It is possible
"            to use match variables so you could do something like:
"            'reg:|src/\([^/]*\)|inc/\1||' (see 'help :substitute', 
"            'help pattern' and 'help sub-replace-special' for more details
" https://superuser.com/questions/313064/switching-between-src-and-include-files-in-vim/313113#313113
" let g:alternateSearchPath = 'reg:#\<src\>$#include#,reg:#\<include\>$#src#'

let g:gitgutter_terminal_reports_focus = 0 " or autocmd BufReadPost * :GitGutterAll


let g:grepper = {}
let g:grepper.tools = ['rg', 'ag', 'ack', 'ack-grep', 'grep', 'findstr', 'pt', 'sift']
nmap gs  <plug>(GrepperOperator)
vmap gs  <plug>(GrepperOperator)

nnoremap <C-p> :echo "use \<leader\>ff"<CR>
" let g:Lf_ShortcutF = "<leader>ff"
let g:Lf_ShortcutF = ""
let g:clap_layout = { 'relative': 'editor' }
nnoremap <silent> <leader>ff :Clap files<CR>
let g:Lf_ShortcutB = ""
nnoremap <silent> <leader>fb :Clap buffers<CR>
nnoremap <silent> <leader>fm :Clap recent_files <CR>
nnoremap <silent> <F2> :Clap tags<CR>
nnoremap <silent> <leader>f/ :Clap blines<CR>
nnoremap <silent> <leader>f? :Clap lines<CR>
nnoremap <silent> <leader>fc :Clap command<CR>


let g:startify_bookmarks = [ '~/.zshrc' ]
let g:startify_lists = [
      \ { 'type': 'sessions',  'header': ['   Sessions']       },
      \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
      \ { 'type': 'files',     'header': ['   MRU']            },
      \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
      \ { 'type': 'commands',  'header': ['   Commands']       },
      \ ]

" nnoremap <leader>fc :Bdelete<CR>
nnoremap <leader>hve :edit $MYVIMRC<CR>
nnoremap <leader>hvr :source $MYVIMRC<CR>

let g:startify_session_persistence=1

set completeopt=menu,menuone,preview,noselect,noinsert
inoremap <C-Space> <Plug>(ale_complete)
nnoremap <silent> <F20> <Plug>(ale_previous)
nnoremap <silent> <F8> <Plug>(ale_next)

autocmd FileType markdown set foldexpr=NestedMarkdownFolds()

" https://github.com/nanotee/nvim-lua-guide
lua << EOF
  require("which-key").setup {
  }
EOF

let g:vim_markdown_folding_style_pythonic = 1

let g:netrw_fastbrowse=0
